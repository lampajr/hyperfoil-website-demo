<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Getting Started on Hyperfoil</title><link>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/</link><description>Recent content in Getting Started on Hyperfoil</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/index.xml" rel="self" type="application/rss+xml"/><item><title>First benchmark</title><link>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart1/</guid><description>1. Download latest release and unpack it wget {{ site.last_release.url }} \ &amp;amp;&amp;amp; unzip {{ site.last_release.zip }} \ &amp;amp;&amp;amp; cd {{ site.last_release.dir }} 2. Start Hyperfoil in interactive mode (CLI) bin/cli.sh For our first benchmark we&amp;rsquo;ll start an embedded server (controller) within the CLI:
[hyperfoil]$ start-local Starting controller in default directory (/tmp/hyperfoil) Controller started, listening on 127.0.0.1:41621 Connecting to the controller... Connected! 3. Upload the minimalistic benchmark and run it As you can see below, the benchmark is really minimalistic as it is doing only single request to http://hyperfoil.</description></item><item><title>Steps and statistics</title><link>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart2/</guid><description>In previous quickstart you created a benchmark that fires only one HTTP request. Our next example is going to hit random URLs at this server with 10 requests per second. We&amp;rsquo;ll see how to generate random data and collect statistics for different URLs.
Let&amp;rsquo;s start a container that will serve the requests:
podman run --rm -p 8080:8083 quay.io/hyperfoil/hyperfoil-examples If you prefer running this in Docker just replace podman with docker. You can explore the handling of requests from this example on GitHub.</description></item><item><title>Complex workflow</title><link>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart3/</guid><description>The previous example was the first &amp;lsquo;real&amp;rsquo; benchmark, but it didn&amp;rsquo;t do anything different from what you could run through wrk, ab, siege or similar tools.
Of course, the results were not suffering from the coordinated omission problem, but Hyperfoil can do more. Let&amp;rsquo;s try a more complex scenario:
name: choose-movie http: host: http://localhost:8080 # Use 80 concurrent HTTP connections to the server. Default is 1, # therefore we couldn&amp;#39;t issue two concurrent requests (as HTTP pipelining # is disabled by default and we use HTTP 1.</description></item><item><title>Phases - basics</title><link>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart4/</guid><description>So far the benchmark contained only one type of load; certain number of users hitting the system, doing always the same (though data could be randomized). In practice you might want to simulate several types of workloads at once: in an eshop users would come browsing or buying products, and operators would restock the virtual warehouse.
Also, driving constant load may not be the best way to run the benchmark: often you want to slowly ramp the load up to let the system adjust (scale up, perform JIT, fill pools) and push the full load only after that.</description></item><item><title>Phases - advanced</title><link>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart5/</guid><description>Previous quickstart presented a benchmark with three phases that all started at the same moment (when the benchmark was started) and had the same duration - different phases represented different workflows (types of user). In this example we will adjust the benchmark to scale the load gradually up.
At this point it would be useful to mention the lifecycle of phases; phase is in one of these states:
not started: As the name clearly says, the phase is not yet started.</description></item><item><title>Running the server</title><link>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart6/</guid><description>Until now we have always started our benchmarks using an embedded controller in the CLI, using the start-local command. This spawns a server in the CLI JVM. CLI communicates with it using standard REST API, though the server port is randomized and listens on localhost only. All the benchmarks and run results are also stored in /tmp/hyperfoil/ - you can change the directory as an argument to the start-local command. While the embedded controller might be convenient for a quick test or when developing the scenario it&amp;rsquo;s not something that you&amp;rsquo;d use for a full-fledged benchmark.</description></item><item><title>Clustered mode</title><link>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart7/</guid><description>Previously we&amp;rsquo;ve learned to start Hyperfoil in standalone server mode, and to do some runs through CLI. In this quickstart we&amp;rsquo;ll see how to run your benchmark distributed to several agent nodes.
Hyperfoil operates as a cluster of Vert.x. When the benchmark is started, it deploys agents on other nodes according to the benchmark configuration - these are Vert.x nodes, too. Together controller and agents form a cluster and communicate over the event bus.</description></item><item><title>Custom components</title><link>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lampajr.github.io/hyperfoil-website-demo/docs/getting-started/quickstart8/</guid><description>Hyperfoil offers some basic steps to do HTTP requests, generate data, alter control flow in the scenario etc., but your needs may surpass the features implemented so far. Also, it might be just easier to express your logic in Java code than combining steps in the YAML. The downside is reduced ability to reuse and more tight dependency on Hyperfoil APIs.
This quickstart will show you how to extend Hyperfoil with custom steps and handlers.</description></item></channel></rss>