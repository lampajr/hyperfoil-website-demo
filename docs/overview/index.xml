<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Overview on Hyperfoil</title><link>https://lampajr.github.io/hyperfoil-website-demo/docs/overview/</link><description>Recent content in Overview on Hyperfoil</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://lampajr.github.io/hyperfoil-website-demo/docs/overview/index.xml" rel="self" type="application/rss+xml"/><item><title>Concepts</title><link>https://lampajr.github.io/hyperfoil-website-demo/docs/overview/concepts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lampajr.github.io/hyperfoil-website-demo/docs/overview/concepts/</guid><description>This document explains some core terms used throughout the documentation.
Controller and agents While it is possible to run benchmarks directly from CLI, in its nature Hyperfoil is a distributed tool with leader-follower architecture. Controller has the leader role; this is a Vert.x-based server with REST API. When a benchmark is started controller deploys agents (according to the benchmark definition), pushes the benchmark definition to these agents and orchestrates benchmark phases.</description></item><item><title>FAQ</title><link>https://lampajr.github.io/hyperfoil-website-demo/docs/overview/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lampajr.github.io/hyperfoil-website-demo/docs/overview/faq/</guid><description>Why is Hyperfoil written in Java? People are often concerned about JVM performance or predictability. While nowadays JVM is very good in the sense of throughput, dealing with jitter can be challenging. We are Java engineers, though, and we believe that these issues can be mitigated with a right design. That&amp;rsquo;s why we try to be very careful on the execution hot-path.
We could achieve even better properties with C/C++, but the development effectivity would suffer.</description></item></channel></rss>